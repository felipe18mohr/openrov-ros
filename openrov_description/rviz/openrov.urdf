<?xml version="1.0" encoding="utf-8"?>
<!-- =================================================================================== -->
<!-- |    This document was autogenerated by xacro from /home/felipe/openrov_ws/src/openrov-ros/openrov_description/robots/default.xacro | -->
<!-- |    EDITING THIS FILE BY HAND IS NOT RECOMMENDED                                 | -->
<!-- =================================================================================== -->
<robot name="openrov">
  <!-- Some pretty colors -->
  <material name="blue">
    <color rgba="0.0 0.0 0.8 1.0"/>
  </material>
  <material name="green">
    <color rgba="0.0 0.8 0.0 1.0"/>
  </material>
  <material name="grey">
    <color rgba="0.7 0.7 0.7 1.0"/>
  </material>
  <material name="grey2">
    <color rgba="0.9 0.9 0.9 1.0"/>
  </material>
  <material name="red">
    <color rgba="0.8 0.0 0.0 1.0"/>
  </material>
  <material name="orange">
    <color rgba="1.0 0.5 0.0 1.0"/>
  </material>
  <material name="white">
    <color rgba="1.0 1.0 1.0 1.0"/>
  </material>
  <material name="black">
    <color rgba="0.05 0.05 0.05 1.0"/>
  </material>
  <!-- ROTOR DYNAMICS MACROS -->
  <!-- First order dynamics -->
  <!--
    MACROS FOR CONVERSION FUNCTIONS BETWEEN ROTOR'S ANG. VELOCITY AND
    THRUSTER FORCE
  -->
  <!-- THRUSTER MODULE MACROS  -->
  <!--
    Thruster model with first order dynamic model for the rotor dynamics
    and a proportional non-linear steady-state conversion from the rotor's
    angular velocity to output thrust force
  -->
  <!--                                                                      -->
  <!-- MACRO FOR THRUSTER UNITS  -->
  <!--                                                                      -->
  <!--
    Vehicle's parameters (remember to enter the model parameters below)
  -->
  <!-- Collision geometry mesh, usually in STL format (it is recommended to keep
  this geometry as simple as possible to improve the performance the physics engine
  regarding the computation of collision forces) -->
  <!--xacro:property name="collision_mesh_file" value="file://$(find openrov_description)/meshes/vehicle.stl"/-->
  <!-- Rigid body description of the base link -->
  <link name="openrov/base_link">
    <!--
          Be careful to setup the coefficients for the inertial tensor,
          otherwise your model will become unstable on Gazebo
        -->
    <inertial>
      <mass value="2.47"/>
      <origin rpy="0 0 0" xyz="-0.062 0 0.062"/>
      <inertia ixx="1.752e-2" ixy="1.593e-5" ixz="1.803e-3" iyy="1.265e-2" iyz="2.172e-5" izz="2.141e-2"/>
    </inertial>
    <visual>
      <origin rpy="0 0 0" xyz="0 0 0"/>
      <geometry>
        <mesh filename="file:///home/felipe/openrov_ws/src/openrov-ros/openrov_description/meshes/vehicle.dae" scale="1 1 1"/>
      </geometry>
    </visual>
    <collision>
      <origin rpy="0 0 0" xyz="0 0 0"/>
      <geometry>
        <!--mesh filename="${collision_mesh_file}" scale="${scale}" /-->
        <box size="0.30 0.20 0.15"/>
      </geometry>
    </collision>
  </link>
  <gazebo reference="openrov/base_link">
    <selfCollide>false</selfCollide>
  </gazebo>
  <!-- Set up hydrodynamic plugin given as input parameter -->
  <gazebo>
    <plugin filename="libuuv_underwater_object_ros_plugin.so" name="uuv_plugin">
      <fluid_density>1028.0</fluid_density>
      <flow_velocity_topic>hydrodynamics/current_velocity</flow_velocity_topic>
      <debug>0</debug>
      <!-- List of hydrodynamic models this robot's links -->
      <link name="openrov/base_link">
        <!-- This flag will make the link neutrally buoyant -->
        <neutrally_buoyant>0</neutrally_buoyant>
        <!-- Link's volume -->
        <volume>0.0024</volume>
        <!-- Link's bounding box, it is used to recalculate the immersed
        volume when close to the surface.
        This is a workaround the invalid bounding box given by Gazebo-->
        <box>
          <width>0.2</width>
          <length>0.3</length>
          <height>0.15</height>
        </box>
        <!-- Center of buoyancy -->
        <center_of_buoyancy>0.004 0 0.009</center_of_buoyancy>
        <!--
        Choose one of the hydrodynamic models below, all are based on
        Fossen's equation of motion for underwater vehicles

        Reference:
        [1] Fossen, Thor I. Handbook of marine craft hydrodynamics and motion
            control. John Wiley & Sons, 2011.
        -->
        <!-- 1) Fossen's equation of motion -->
        <hydrodynamic_model>
          <type>fossen</type>
          <added_mass>
            0 0 0 0 0 0
            0 0 0 0 0 0
            0 0 0 0 0 0
            0 0 0 0 0 0
            0 0 0 0 0 0
            0 0 0 0 0 0
          </added_mass>
          <!--
            The linear damping coefficients can be provided as a diagonal (6 elements)
            or a full matrix (36 coefficients), like the added-mass coefficients above
          -->
          <linear_damping>
            0 0 0 0 0 0
          </linear_damping>
          <!--
            The linear damping coefficients proportional to the forward speed
            can be provided as a diagonal (6 elements) or a full matrix (36 coefficients),
            like the added-mass coefficients above.
            This matrix is mostly useful for slender bodies (e.g. AUVs with torpedo shape)
          -->
          <!--linear_damping_forward_speed>
            0 0 0 0 0 0
          </linear_damping_forward_speed-->
          <!--
            The quadratic damping coefficients can be provided as a diagonal (6 elements)
            or a full matrix (36 coefficients), like the added-mass coefficients above
          -->
          <quadratic_damping>
            0 0 0 0 0 0
          </quadratic_damping>
          <!--
            In case you want to model a simple surface vessel, you can use the
            implementation of linear (small angle) theory for boxed shaped vessels
            by providing the following parameters. If you omit the area of the
            water level plane area, it will be calculated from the bounding box
            parameters. Uncomment the lines below in case you are simulating a
            surface vessel.
            For more details on these parameters and the computation of buoyancy
            for vessels using this theory, check:
              [1] Lecture Notes  TTK 4190 Guidance and Control of Vehicles (T. I. Fossen)
                  http://www.fossen.biz/wiley/Ch4.pdf
              [2] Fossen, Thor I. Handbook of marine craft hydrodynamics and motion
                  control. John Wiley & Sons, 2011.
          -->
          <!--
          <metacentric_width>0.0</metacentric_width>
          <metacentric_length>0.0</metacentric_length>
          <submerged_height>0.0</submerged_height>
          -->
        </hydrodynamic_model>
        <!-- 2) This computes the added-mass and damping parameters for a sphere
        in the fluid with the given radius >
        <hydrodynamic_model>
          <type>sphere</type>
          <radius>0</radius>
        </hydrodynamic_model-->
      </link>
      <!--
          In case other modules are added to the vehicle (such as a manipulator)
          that also have link running with the underwater object plugin, they
          should also be added in this block. For this, this new module should
          have a file similar to gazebo.xacro above with the description of the
          parameter necessary for the underwater object plugin to be initialized.
        -->
    </plugin>
  </gazebo>
  <!-- Adding the thruster units with the macro created in snippets.xacro -->
  <!--
    Important:
        - The thruster IDs must be given as integers and must be unique to each thruster unit
        - The thruster pose in the <origin> block is relative to the body's center of mass. Be
          aware that Gazebo does not use the SNAME convention per default.
    -->
  <!--
    Dummy link as place holder for the thruster frame,
    since thrusters can often be inside the collision geometry
    of the vehicle and may cause internal collisions if set otherwise
    -->
  <link name="openrov/thruster_0">
    <visual>
      <geometry>
        <mesh filename="file:///home/felipe/openrov_ws/src/openrov-ros/openrov_description/meshes/propeller.dae" scale="1 1 1"/>
      </geometry>
    </visual>
    <inertial>
      <mass value="0.001"/>
      <origin rpy="0 0 0" xyz="0 0 0"/>
      <inertia ixx="0.000000017" ixy="0.0" ixz="0.0" iyy="0.000000017" iyz="0.0" izz="0.000000017"/>
    </inertial>
  </link>
  <!-- Joint between thruster link and vehicle base link -->
  <joint name="openrov/thruster_0_joint" type="continuous">
    <origin rpy="0 -1.5707963 0" xyz="-0.062 0 0.062"/>
    <axis xyz="1 0 0"/>
    <parent link="openrov/base_link"/>
    <child link="openrov/thruster_0"/>
  </joint>
  <gazebo>
    <!-- Thruster ROS plugin -->
    <plugin filename="libuuv_thruster_ros_plugin.so" name="openrov_0_thruster_model">
      <!-- Name of the thruster link -->
      <linkName>openrov/thruster_0</linkName>
      <!-- Name of the joint between thruster and vehicle base link -->
      <jointName>openrov/thruster_0_joint</jointName>
      <!-- Make the thruster aware of its id -->
      <thrusterID>0</thrusterID>
      <!-- Gain of the input command signal -->
      <gain>1</gain>
      <!-- Minimum and maximum allowed input value for the input signal for thruster unit -->
      <clampMin>-100</clampMin>
      <clampMax>100</clampMax>
      <!-- Minimum and maximum thrust force output allowed -->
      <thrustMin>-100</thrustMin>
      <thrustMax>100</thrustMax>
      <!--
        Value from 0 to 1 to set the efficiency of the output thrust force
        Default value is 1.0
        -->
      <thrust_efficiency>1</thrust_efficiency>
      <!--
        Value from 0 to 1 to set the efficiency of the propeller as a factor
        to be multiplied to the current value of the state variable at each
        iteration.
        Default value is 1.0
        -->
      <propeller_efficiency>1</propeller_efficiency>
      <!--
        Choose one of the propeller dynamics models below for your implementation
        This will describe the dynamic model for the state variable of your thruster unit,
        which can be, e.g., the angular velocity of the propeller.
        -->
      <!-- 1) Simple zero-order model -->
      <dynamics>
        <type>ZeroOrder</type>
      </dynamics>
      <!-- 2) First order model -->
      <!--dynamics>
          <type>FirstOrder</type>
          <timeConstant>0.0</timeConstant>
        </dynamics-->
      <!-- 3) Yoerger's nonlinear dynamic model
        For information on the model description:
        [1] D. R. Yoerger, J. G. Cooke, and J.-J. E. Slotine, "The influence of
            thruster dynamics on underwater vehicle behavior and their incorporation
            into control system design," IEEE Journal of Oceanic Engineering, vol. 15,
            no. 3, pp. 167-178, Jul. 1990.
        -->
      <!--dynamics>
          <type>Yoerger</type>
          <alpha>0.0</alpha>
          <beta>0.0</beta>
        </dynamics-->
      <!-- 4) Bessa's nonlinear dynamic model
        For information on the model description:
        [2] Bessa, Wallace Moreira, Max Suell Dutra, and Edwin Kreuzer. "Thruster
            dynamics compensation for the positioning of underwater robotic vehicles
            through a fuzzy sliding mode based approach." ABCM Symposium Series in
            Mechatronics. Vol. 2. 2006.
        -->
      <!--dynamics>
          <type>Bessa</type>
          <Jmsp>0.0</Jmsp>
          <Kv1>0.0</Kv1>
          <Kv2>0.0</Kv2>
          <Kt>0.0</Kt>
          <Rm>0.0</Rm>
        </dynamics-->
      <!--
        Choose one of the model for the steady-state curve describing the
        relationship between the state variable and the output thrust force
        -->
      <!-- 1) Basic curve
        Input: x
        Output: thrust
        Function: thrust = rotorConstant * x * abs(x)
        -->
      <conversion>
        <type>Basic</type>
        <rotorConstant>1.0</rotorConstant>
      </conversion>
      <!-- 2) Dead-zone nonlinearity described in Bessa, 2006
        Input: x
        Output: thrust
        Function:
        thrust = rotorConstantL * (x * abs(x) - deltaL), if x * abs(x) <= deltaL
        thrust = 0, if deltaL < x * abs(x) < deltaR
        thrust = rotorConstantR * (x * abs(x) - deltaR), if x * abs(x) >= deltaL
        -->
      <!--conversion>
          <type>Bessa</type>
          <rotorConstantL>0.0</rotorConstantL>
          <rotorConstantR>0.0</rotorConstantR>
          <deltaL>0.0</deltaL>
          <deltaR>0.0</deltaR>
        </conversion-->
      <!-- 3) Linear interpolation
        If you have access to the thruster's data sheet, for example,
        you can enter samples of the curve's input and output values
        and the thruster output will be found through linear interpolation
        of the given samples.
        -->
      <!--conversion>
          <type>LinearInterp</type>
          <inputValues>0 1 2 3</inputValues>
          <outputValues>0 1 2 3</outputValues>
        </conversion-->
    </plugin>
  </gazebo>
  <gazebo reference="openrov/thruster_0">
    <selfCollide>false</selfCollide>
  </gazebo>
  <!--
    Dummy link as place holder for the thruster frame,
    since thrusters can often be inside the collision geometry
    of the vehicle and may cause internal collisions if set otherwise
    -->
  <link name="openrov/thruster_1">
    <visual>
      <geometry>
        <mesh filename="file:///home/felipe/openrov_ws/src/openrov-ros/openrov_description/meshes/propeller.dae" scale="1 1 1"/>
      </geometry>
    </visual>
    <inertial>
      <mass value="0.001"/>
      <origin rpy="0 0 0" xyz="0 0 0"/>
      <inertia ixx="0.000000017" ixy="0.0" ixz="0.0" iyy="0.000000017" iyz="0.0" izz="0.000000017"/>
    </inertial>
  </link>
  <!-- Joint between thruster link and vehicle base link -->
  <joint name="openrov/thruster_1_joint" type="continuous">
    <origin rpy="0 0 3.1415926" xyz="-0.14 -0.045 0"/>
    <axis xyz="1 0 0"/>
    <parent link="openrov/base_link"/>
    <child link="openrov/thruster_1"/>
  </joint>
  <gazebo>
    <!-- Thruster ROS plugin -->
    <plugin filename="libuuv_thruster_ros_plugin.so" name="openrov_1_thruster_model">
      <!-- Name of the thruster link -->
      <linkName>openrov/thruster_1</linkName>
      <!-- Name of the joint between thruster and vehicle base link -->
      <jointName>openrov/thruster_1_joint</jointName>
      <!-- Make the thruster aware of its id -->
      <thrusterID>1</thrusterID>
      <!-- Gain of the input command signal -->
      <gain>1</gain>
      <!-- Minimum and maximum allowed input value for the input signal for thruster unit -->
      <clampMin>-100</clampMin>
      <clampMax>100</clampMax>
      <!-- Minimum and maximum thrust force output allowed -->
      <thrustMin>-100</thrustMin>
      <thrustMax>100</thrustMax>
      <!--
        Value from 0 to 1 to set the efficiency of the output thrust force
        Default value is 1.0
        -->
      <thrust_efficiency>1</thrust_efficiency>
      <!--
        Value from 0 to 1 to set the efficiency of the propeller as a factor
        to be multiplied to the current value of the state variable at each
        iteration.
        Default value is 1.0
        -->
      <propeller_efficiency>1</propeller_efficiency>
      <!--
        Choose one of the propeller dynamics models below for your implementation
        This will describe the dynamic model for the state variable of your thruster unit,
        which can be, e.g., the angular velocity of the propeller.
        -->
      <!-- 1) Simple zero-order model -->
      <dynamics>
        <type>ZeroOrder</type>
      </dynamics>
      <!-- 2) First order model -->
      <!--dynamics>
          <type>FirstOrder</type>
          <timeConstant>0.0</timeConstant>
        </dynamics-->
      <!-- 3) Yoerger's nonlinear dynamic model
        For information on the model description:
        [1] D. R. Yoerger, J. G. Cooke, and J.-J. E. Slotine, "The influence of
            thruster dynamics on underwater vehicle behavior and their incorporation
            into control system design," IEEE Journal of Oceanic Engineering, vol. 15,
            no. 3, pp. 167-178, Jul. 1990.
        -->
      <!--dynamics>
          <type>Yoerger</type>
          <alpha>0.0</alpha>
          <beta>0.0</beta>
        </dynamics-->
      <!-- 4) Bessa's nonlinear dynamic model
        For information on the model description:
        [2] Bessa, Wallace Moreira, Max Suell Dutra, and Edwin Kreuzer. "Thruster
            dynamics compensation for the positioning of underwater robotic vehicles
            through a fuzzy sliding mode based approach." ABCM Symposium Series in
            Mechatronics. Vol. 2. 2006.
        -->
      <!--dynamics>
          <type>Bessa</type>
          <Jmsp>0.0</Jmsp>
          <Kv1>0.0</Kv1>
          <Kv2>0.0</Kv2>
          <Kt>0.0</Kt>
          <Rm>0.0</Rm>
        </dynamics-->
      <!--
        Choose one of the model for the steady-state curve describing the
        relationship between the state variable and the output thrust force
        -->
      <!-- 1) Basic curve
        Input: x
        Output: thrust
        Function: thrust = rotorConstant * x * abs(x)
        -->
      <conversion>
        <type>Basic</type>
        <rotorConstant>1.0</rotorConstant>
      </conversion>
      <!-- 2) Dead-zone nonlinearity described in Bessa, 2006
        Input: x
        Output: thrust
        Function:
        thrust = rotorConstantL * (x * abs(x) - deltaL), if x * abs(x) <= deltaL
        thrust = 0, if deltaL < x * abs(x) < deltaR
        thrust = rotorConstantR * (x * abs(x) - deltaR), if x * abs(x) >= deltaL
        -->
      <!--conversion>
          <type>Bessa</type>
          <rotorConstantL>0.0</rotorConstantL>
          <rotorConstantR>0.0</rotorConstantR>
          <deltaL>0.0</deltaL>
          <deltaR>0.0</deltaR>
        </conversion-->
      <!-- 3) Linear interpolation
        If you have access to the thruster's data sheet, for example,
        you can enter samples of the curve's input and output values
        and the thruster output will be found through linear interpolation
        of the given samples.
        -->
      <!--conversion>
          <type>LinearInterp</type>
          <inputValues>0 1 2 3</inputValues>
          <outputValues>0 1 2 3</outputValues>
        </conversion-->
    </plugin>
  </gazebo>
  <gazebo reference="openrov/thruster_1">
    <selfCollide>false</selfCollide>
  </gazebo>
  <!--
    Dummy link as place holder for the thruster frame,
    since thrusters can often be inside the collision geometry
    of the vehicle and may cause internal collisions if set otherwise
    -->
  <link name="openrov/thruster_2">
    <visual>
      <geometry>
        <mesh filename="file:///home/felipe/openrov_ws/src/openrov-ros/openrov_description/meshes/propeller.dae" scale="1 1 1"/>
      </geometry>
    </visual>
    <inertial>
      <mass value="0.001"/>
      <origin rpy="0 0 0" xyz="0 0 0"/>
      <inertia ixx="0.000000017" ixy="0.0" ixz="0.0" iyy="0.000000017" iyz="0.0" izz="0.000000017"/>
    </inertial>
  </link>
  <!-- Joint between thruster link and vehicle base link -->
  <joint name="openrov/thruster_2_joint" type="continuous">
    <origin rpy="0 0 3.1415926" xyz="-0.14 0.045 0"/>
    <axis xyz="1 0 0"/>
    <parent link="openrov/base_link"/>
    <child link="openrov/thruster_2"/>
  </joint>
  <gazebo>
    <!-- Thruster ROS plugin -->
    <plugin filename="libuuv_thruster_ros_plugin.so" name="openrov_2_thruster_model">
      <!-- Name of the thruster link -->
      <linkName>openrov/thruster_2</linkName>
      <!-- Name of the joint between thruster and vehicle base link -->
      <jointName>openrov/thruster_2_joint</jointName>
      <!-- Make the thruster aware of its id -->
      <thrusterID>2</thrusterID>
      <!-- Gain of the input command signal -->
      <gain>1</gain>
      <!-- Minimum and maximum allowed input value for the input signal for thruster unit -->
      <clampMin>-100</clampMin>
      <clampMax>100</clampMax>
      <!-- Minimum and maximum thrust force output allowed -->
      <thrustMin>-100</thrustMin>
      <thrustMax>100</thrustMax>
      <!--
        Value from 0 to 1 to set the efficiency of the output thrust force
        Default value is 1.0
        -->
      <thrust_efficiency>1</thrust_efficiency>
      <!--
        Value from 0 to 1 to set the efficiency of the propeller as a factor
        to be multiplied to the current value of the state variable at each
        iteration.
        Default value is 1.0
        -->
      <propeller_efficiency>1</propeller_efficiency>
      <!--
        Choose one of the propeller dynamics models below for your implementation
        This will describe the dynamic model for the state variable of your thruster unit,
        which can be, e.g., the angular velocity of the propeller.
        -->
      <!-- 1) Simple zero-order model -->
      <dynamics>
        <type>ZeroOrder</type>
      </dynamics>
      <!-- 2) First order model -->
      <!--dynamics>
          <type>FirstOrder</type>
          <timeConstant>0.0</timeConstant>
        </dynamics-->
      <!-- 3) Yoerger's nonlinear dynamic model
        For information on the model description:
        [1] D. R. Yoerger, J. G. Cooke, and J.-J. E. Slotine, "The influence of
            thruster dynamics on underwater vehicle behavior and their incorporation
            into control system design," IEEE Journal of Oceanic Engineering, vol. 15,
            no. 3, pp. 167-178, Jul. 1990.
        -->
      <!--dynamics>
          <type>Yoerger</type>
          <alpha>0.0</alpha>
          <beta>0.0</beta>
        </dynamics-->
      <!-- 4) Bessa's nonlinear dynamic model
        For information on the model description:
        [2] Bessa, Wallace Moreira, Max Suell Dutra, and Edwin Kreuzer. "Thruster
            dynamics compensation for the positioning of underwater robotic vehicles
            through a fuzzy sliding mode based approach." ABCM Symposium Series in
            Mechatronics. Vol. 2. 2006.
        -->
      <!--dynamics>
          <type>Bessa</type>
          <Jmsp>0.0</Jmsp>
          <Kv1>0.0</Kv1>
          <Kv2>0.0</Kv2>
          <Kt>0.0</Kt>
          <Rm>0.0</Rm>
        </dynamics-->
      <!--
        Choose one of the model for the steady-state curve describing the
        relationship between the state variable and the output thrust force
        -->
      <!-- 1) Basic curve
        Input: x
        Output: thrust
        Function: thrust = rotorConstant * x * abs(x)
        -->
      <conversion>
        <type>Basic</type>
        <rotorConstant>1.0</rotorConstant>
      </conversion>
      <!-- 2) Dead-zone nonlinearity described in Bessa, 2006
        Input: x
        Output: thrust
        Function:
        thrust = rotorConstantL * (x * abs(x) - deltaL), if x * abs(x) <= deltaL
        thrust = 0, if deltaL < x * abs(x) < deltaR
        thrust = rotorConstantR * (x * abs(x) - deltaR), if x * abs(x) >= deltaL
        -->
      <!--conversion>
          <type>Bessa</type>
          <rotorConstantL>0.0</rotorConstantL>
          <rotorConstantR>0.0</rotorConstantR>
          <deltaL>0.0</deltaL>
          <deltaR>0.0</deltaR>
        </conversion-->
      <!-- 3) Linear interpolation
        If you have access to the thruster's data sheet, for example,
        you can enter samples of the curve's input and output values
        and the thruster output will be found through linear interpolation
        of the given samples.
        -->
      <!--conversion>
          <type>LinearInterp</type>
          <inputValues>0 1 2 3</inputValues>
          <outputValues>0 1 2 3</outputValues>
        </conversion-->
    </plugin>
  </gazebo>
  <gazebo reference="openrov/thruster_2">
    <selfCollide>false</selfCollide>
  </gazebo>
  <link name="openrov/camera_link">
    <visual>
      <origin rpy="0.0 0.0 0.0" xyz="0.0 0.0 0.0"/>
      <geometry>
        <mesh filename="/home/felipe/openrov_ws/src/openrov-ros/openrov_description/meshes/camera.dae"/>
      </geometry>
    </visual>
    <inertial>
      <origin rpy="0.0 0.0 0.0" xyz="0.0 0.0 0.0"/>
      <mass value="0.001"/>
      <inertia ixx="0.00000001" ixy="0.0" ixz="0.0" iyy="0.00000001" iyz="0.0" izz="0.00000001"/>
    </inertial>
  </link>
  <link name="openrov/camera_fix">
    <visual>
      <origin rpy="0 0 0" xyz="0.05 0 0"/>
      <geometry>
        <box size="0.01 0.01 0.01"/>
      </geometry>
    </visual>
    <inertial>
      <origin rpy="0.0 0.0 0.0" xyz="0.0 0.0 0.0"/>
      <mass value="0.001"/>
      <inertia ixx="0.00000001" ixy="0.0" ixz="0.0" iyy="0.00000001" iyz="0.0" izz="0.00000001"/>
    </inertial>
  </link>
  <joint name="openrov/camera_to_fix" type="fixed">
    <origin rpy="0 0 0" xyz="0.05 0 0"/>
    <parent link="openrov/camera_fix"/>
    <child link="openrov/camera_link"/>
  </joint>
  <joint name="openrov/base_to_camera" type="revolute">
    <origin rpy="0.0 0.0 0.0" xyz="0.025 0.0 0.015419"/>
    <parent link="openrov/base_link"/>
    <child link="openrov/camera_fix"/>
    <axis xyz="0 1 0"/>
    <limit effort="0.0" lower="-0.78539815" upper="0.78539815" velocity="0.0"/>
  </joint>
  <gazebo reference="openrov/camera_link">
    <sensor name="camera" type="camera">
      <update_rate>30.0</update_rate>
      <camera name="head">
        <horizontal_fov>2.0944</horizontal_fov>
        <image>
          <width>1280</width>
          <height>720</height>
          <format>R8G8B8</format>
        </image>
        <clip>
          <near>0.02</near>
          <far>300</far>
        </clip>
        <noise>
          <type>gaussian</type>
          <!-- Noise is sampled independently per pixel on each frame.
                 That pixel's noise value is added to each of its color
                 channels, which at that point lie in the range [0,1]. -->
          <mean>0.0</mean>
          <stddev>0.007</stddev>
        </noise>
      </camera>
      <plugin filename="libgazebo_ros_camera.so" name="camera_controller">
        <alwaysOn>true</alwaysOn>
        <updateRate>0.0</updateRate>
        <cameraName>camera</cameraName>
        <imageTopicName>image_raw</imageTopicName>
        <cameraInfoTopicName>camera_info</cameraInfoTopicName>
        <frameName>camera_link</frameName>
        <hackBaseline>0.07</hackBaseline>
        <distortionK1>0.0</distortionK1>
        <distortionK2>0.0</distortionK2>
        <distortionK3>0.0</distortionK3>
        <distortionT1>0.0</distortionT1>
        <distortionT2>0.0</distortionT2>
      </plugin>
    </sensor>
  </gazebo>
  <!--transmission name="tran_cam">
      <type>transmission_interface/SimpleTransmission</type>
      <joint name="${namespace}/base_to_camera">
        <hardwareInterface>EffortJointInterface</hardwareInterface>
      </joint>
      <actuator name="motor_cam">
        <hardwareInterface>EffortJointInterface</hardwareInterface>
        <mechanicalReduction>1</mechanicalReduction>
      </actuator>
    </transmission-->
  <gazebo>
    <plugin filename="libgazebo_ros_control.so" name="gazebo_ros_control">
      <robotNamespace>/openrov</robotNamespace>
    </plugin>
  </gazebo>
  <!-- Mount a 3D pose sensor -->
  <link name="openrov/pose_sensor_link_default">
    <inertial>
      <inertia ixx="0.00001" ixy="0.0" ixz="0.0" iyy="0.00001" iyz="0.0" izz="0.00001"/>
      <mass value="0.001"/>
      <!-- [kg] -->
      <origin rpy="0 0 0" xyz="0 0 0"/>
    </inertial>
  </link>
  <joint name="openrov/pose_sensor_default_joint" type="revolute">
    <origin rpy="0 0 0" xyz="0 0 0"/>
    <axis xyz="0 0 1"/>
    <parent link="openrov/base_link"/>
    <child link="openrov/pose_sensor_link_default"/>
    <limit effort="0" lower="0" upper="0" velocity="0"/>
  </joint>
  <gazebo>
    <plugin filename="libuuv_gazebo_ros_pose_gt_plugin.so" name="pose_3d_plugin">
      <robot_namespace>openrov</robot_namespace>
      <link_name>openrov/base_link</link_name>
      <sensor_topic>pose_gt</sensor_topic>
      <static_reference_frame>world</static_reference_frame>
      <noise_sigma>0.0</noise_sigma>
      <noise_amplitude>0.0</noise_amplitude>
      <update_rate>20</update_rate>
      <enable_gazebo_messages>false</enable_gazebo_messages>
      <publish_ned_odom>False</publish_ned_odom>
    </plugin>
  </gazebo>
  <gazebo>
    <plugin filename="libuuv_joint_state_publisher.so" name="uuv_joint_state_publisher">
      <robotNamespace>openrov</robotNamespace>
      <updateRate>50</updateRate>
    </plugin>
  </gazebo>
</robot>
